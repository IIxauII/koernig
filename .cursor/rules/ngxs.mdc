---
description: NGXS state management patterns, store structure, actions, and selectors for complex application state
globs: ["libs/mobile/data-access/**/*.ts", "apps/mobile/src/**/*state*.ts"]
alwaysApply: false
---

# NGXS State Management

This project uses NGXS for managing complex application state across the mobile application.

## Store Structure

* **Feature Stores:** Organize stores by feature/domain (e.g., `FilmState`, `CameraState`). Each feature should have its own store.
* **Store Location:** Place stores in `libs/mobile/data-access/` following the pattern: `libs/mobile/data-access/[feature]/[feature].state.ts`
* **State Interface:** Define state interfaces in the same file or in a separate `[feature].state.model.ts` file.

## Actions

* **Action Naming:** Use descriptive action names following the pattern: `[Feature] Action Description` (e.g., `[Film] Load Films`, `[Film] Add Film`).
* **Action Classes:** Use action classes, not action creators, for type safety:
  ```typescript
  export class LoadFilms {
    static readonly type = '[Film] Load Films';
  }
  
  export class AddFilm {
    static readonly type = '[Film] Add Film';
    constructor(public film: Film) {}
  }
  ```
* **Action Organization:** Group related actions in the same file: `[feature].actions.ts`

## State Classes

* **State Decorator:** Use `@State` decorator with proper configuration:
  ```typescript
  @State<FilmStateModel>({
    name: 'films',
    defaults: {
      films: [],
      loading: false,
      error: null
    }
  })
  export class FilmState {
    // ...
  }
  ```
* **Action Handlers:** Use `@Action` decorator for handling actions:
  ```typescript
  @Action(LoadFilms)
  loadFilms(ctx: StateContext<FilmStateModel>) {
    // Implementation
  }
  ```
* **Async Operations:** Use RxJS operators for async operations in action handlers. Handle errors appropriately.

## Selectors

* **Selector Naming:** Use descriptive selector names. Prefer `@Selector()` decorator:
  ```typescript
  @Selector([FilmState])
  static films(state: FilmStateModel) {
    return state.films;
  }
  ```
* **Computed Selectors:** Create computed selectors for derived state using `createSelector`.
* **Selector Location:** Place selectors in the state class or in a separate `[feature].selectors.ts` file.

## Integration with Components

* **Store Injection:** Inject the store using `inject()` function:
  ```typescript
  private store = inject(Store);
  ```
* **Selecting State:** Use `store.select()` or `store.selectSnapshot()`:
  ```typescript
  films$ = this.store.select(FilmState.films);
  // or for one-time reads
  const films = this.store.selectSnapshot(FilmState.films);
  ```
* **Dispatching Actions:** Dispatch actions using `store.dispatch()`:
  ```typescript
  this.store.dispatch(new LoadFilms());
  ```

## Persistence

* **Ionic Storage Plugin:** Use NGXS Storage Plugin to persist state to Ionic Storage.
* **Selective Persistence:** Only persist necessary state slices, not entire state trees.
* **Storage Keys:** Use meaningful storage keys following the pattern: `[feature]_state`.

## Best Practices

* **Immutable Updates:** Always return new state objects, never mutate existing state.
* **Pure Functions:** Keep action handlers pure and predictable.
* **Error Handling:** Include error state in state models and handle errors in action handlers.
* **Loading States:** Include loading flags in state for async operations.
* **Type Safety:** Use TypeScript interfaces for all state models and action payloads.
